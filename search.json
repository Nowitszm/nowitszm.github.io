[{"title":"计算虚拟化","url":"/2022/05/19/%E8%AE%A1%E7%AE%97%E8%99%9A%E6%8B%9F%E5%8C%96/","content":"一、计算虚拟化虚拟化只是底层硬件和上层操作系统、应用的解耦，提供可灵活分配的技术资源池，可以将服务器的CPU、内存、磁盘等硬件集中管理，通过集中式的动态按需分配，可以提供资源的利用率的底层技术，还需要众多组件协同工作才能完成，提供完整的计算服务。\n1.1 CPU虚拟化 为保障Cpu资源合理调度以及VM上的指令能够高效执行，在宿主机中通过线程或进程这种纯软件方式模拟出vCpu，每台虚拟机把通过Vmm分配的vCpu来调度自己的进程。\n\n总资源&#x3D;服务器Cpu个数 * 单个Cpu * 核数 * 线程\n1.1.1 CPU QosQualiy of Servicef服务质量，用来控制虚拟机使用Cpu资源量，Cpu Qos包括Cpu热拔插、Cpu份额、Cpu配额。\n\nCpu上限资源：控制虚拟机占用物理资源使用的上限\nCpu预留资源：多个虚拟机竞争物理Cpu资源时最低分配的计算资源\nCpu份额资源：多个虚拟机竞争物理Cpu资源时按比例分配的计算资源\nCpu热拔插：虚拟机高负载时，通过热拔插方式进行弹性扩展\n\n1.1.2 NUMANUMA（Non Uniform Memory Access Architecture）非统一内存访问体系结构，主要目的是提高物理服务器性能，解决Cpu负载均衡的问题。将物理服务器的Cpu和内存分到多个node上，NUMA根据当时主机内存和Cpu负载，选择一个复杂较轻的node放置该虚拟机，NUMA保证了一个虚拟机的vCpu尽量分配到同一个node中的物理Cpu上，尽量避免跨node访问，提升虚拟机性能。\n1.2 内存虚拟化操作系统对内存管理是非常复杂的，而内存虚拟化技术也就是虚拟内存（Virtual Memory）相比较于OS内存管理更为复杂。如果虚拟寄存的OS是运行在VM中，为保障内存空间的合理分配、管理利用虚拟化技术实现对物理内存的管理，内存虚拟化抽象了物理内存，虚拟机每个进程都被赋予一块连续完整的虚拟内存空间，而不必担心申请内存和和其他进程冲突。\n1.2.1 内存地址转换在传统的Linux&#x2F;Windows操作系统中，有物理内存和虚拟内存，会涉及到物理地址和虚拟地址的转换。虚拟机本质是宿主机的一个进程，在虚拟化模式下虚拟机处于非Root模式，无法直接访问宿主机的内存，需要VMM介入来模拟宿主机的内存，即VMM获取虚拟机访问内存的指令，VMM在虚拟机的虚拟地址和宿主机的虚拟地址增加了一层（虚拟机的物理地址）。\n\nHost Phyical Address：由Hypervisor转换得到的宿主机物理地址\nGuest Virtual Address：由Hypervisor在Guest VM中的虚拟地址\nHost Virtual Address：宿主机虚拟地址\nGuest Phyical Address：虚拟机物理地址\n\n\n1.2.2 内存虚拟化类型\n软件形式：影子页表技术，为每个虚拟机维护一个影子页表（Shadow Page Table），记录虚拟化内存与物理内存的映射关系，VMM将影子页表提交给CPU的内存管理单元MMU进行地址转换，虚拟家的页表无需改动；\n硬件形式：Intel拓展页表EPT（Extend Page Table）和AMD嵌入页表NPT（Nested Page Table），CPU硬件一个特性，通过硬件方式实现GuestOS物理内存地址到主机物理内存地址的转换。\n\n1.2.3 影子页表技术虚拟机每次内存访问都需要VMM介入，进行四次地址转换，效率较低。影子页表技术简化了地址转换，实现了虚拟机虚拟地址空间对宿主机物理地址空间的直接映射。\n\n在每个虚拟机中，VMM都会对应维护一套对应的影子页表（Shadow Page Table）;\n创建虚拟机时，VMM创建对应的影子页表，当页表是空时，任何访问内存操作都会出现缺页中断，然后VMM捕获异常，逐步完成所有虚拟地址到宿主机地址的映射；\n当虚拟机进程访问内存时，将该进程的影子页表交给宿主机的MMU中，完成地址转换；\nMMU根据影子页表的映射关系，完成GVA到HPA的直接映射。\n\n\n1.2.4 内存复用技术在服务器物理内存一定的情况下，通过运用内存复用技术对内存进行分时复用。通过内存复用，使得虚拟机内存规格总和大于服务器规格内存总和，提高服务器中虚拟机密度。\n\n内存置换：当物理内存紧张的情况，把存储资源虚拟成内存给虚拟机使用，虚拟机上长时间未使用的数据放到存储上，建立映射然后进行数据交换；\n\n\n\n内存气泡：虚拟机将分配到并未使用的内存拿出来形成一个气泡空间，给更多的虚拟机使用，本身虚拟机应用不会产生影响，从而提高物理内存利用率。\n内存共享：即便物理内存分配给了不同的虚拟机，但是通常情况下内存并不会全部占用。多个虚拟机对相同的数据进行共享操作，即多个虚拟机共享一块物理内存。当进行写入操作时，就为这个虚拟机单独开辟一个内存空间，并修改映射，即写时复制。\n\n\n1.3 I&#x2F;O虚拟化通常在一个虚拟化平台中，I&#x2F;O设备需要被多个虚拟机共用，为了保证虚拟机的I&#x2F;O隔离与正常高效的访问，需要对I&#x2F;O设备进行虚拟化。\n1.3.1 三种常见方式\n全虚拟化：宿主机捕获虚拟机对I&#x2F;O设备访问请求，通过软件模拟的形式模拟IO设备；\n半虚拟化：Hypervisor提供资源调用的接口，VM通过特定的调用接口与Hypervisor通信，完成获取完整的I&#x2F;O资源控制操作；\n硬件辅助虚拟化：IO透传技术，直接把物理设备分配给虚拟机使用，Intel VT-d技术\n\n","categories":["Cloud"],"tags":["Linux and cloud"]},{"title":"虚拟化","url":"/2022/05/14/%E8%99%9A%E6%8B%9F%E5%8C%96/","content":"一、虚拟化1.1 虚拟化概念维基百科：“虚拟化是表示计算机资源的逻辑组（或子集）的过程，这样就可以用从原始配置中获益的方式访问它们。这种资源的新虚拟视图并不受实现、地理位置或底层资源的物理配置的限制。”虚拟化（Virtualization）的定义很广泛，只要将一种形式的资源抽象成另外一种形式的技术都可以称为虚拟化技术。通常我们将虚拟化理解为将一台计算机资源通过虚拟化技术虚拟出多台逻辑计算机，每台逻辑计算机独立运行、互不干扰，可同时运行不同的操作系统和应用程序。\n1.2 虚拟化目的虚拟化技术的核心在于资源的抽象化，重新划分IT资源，可以实现IT资源的动态分配、灵活调度、跨域共享，虚拟化技术实现了物理硬件与软件逻辑架构的解耦。举个例子，假设一个完整的系统有2台物理服务器，其中一台做服务端采取Linux系统运行Scada进程，一台做web客户端采取windows系统访问前端页面。每台服务器均使用40%的资源，但是由于系统的差异以及应用程序的差异，这两台服务器都需要保存。借助虚拟化技术，可以分为 2 个能够处理独立任务的特殊服务器，使用率从 40% 提高到 80%，您仍然使用相同的硬件，但可以更加高效地利用这些资源。\n1.3 云计算中的虚拟化云计算是极度依赖虚拟化的，但虚拟化并非云计算，云计算也非虚拟化，虚拟化是云计算的核心技术，但并非是云计算的核心关注点云计算中的虚拟化指的是IaaS层虚拟化解决方案。IaaS层虚拟化解决方案，要符合IaaS层的基础特点，除了最基础的虚拟化软件之外，还包括，共享存储服务，镜像服务，身份认证服务，统一监控服务，以及收费管理等其他配套的服务。当然，既然是IaaS服务，必须支持对外API接口开放，支持定制开发。一般来说不是一个软件，而是一组软件组成的整理解决方案。由于两者的核心理念都是从硬件中分离资源，以创建可用的环境，所以很容易被混为一谈。虚拟化有助于创建云，但它并非实现云计算的决定性技术。你可以这样理解：\n\n虚拟化是一种将功能与硬件分离的技术\n而云计算并不仅仅是依赖于这种分离的解决方案\n云计算的基础是虚拟化，虚拟化只是云计算的一部分\n虚拟化特点：分区、隔离、封装、软硬件解耦\n\n二、虚拟化类型整体来说虚拟化可分为全虚拟化、半虚拟化和硬件辅助虚拟化这三类。\n2.1 全虚拟化全虚拟化（Full Virtualization）是一种由虚拟机协调操作系统和硬件的模型，结构模型如下图所示，操作系统和硬件设备之间通过Hypervisor来协调处理，抽象的VM具有完全的物理特性，虚拟化层负责捕获CPU指令，为指令访问硬件充当媒介。\n全虚拟化为宿主机操作系统提供完整的虚拟平台，如处理器、内存、I&#x2F;O等，全虚拟化运行的宿主机操作系统无需任何修改即可迁移，但全虚拟化在性能方面不如裸机，因为Hypervisor在运行时需要占用一定的资源，另外一个影响性能开销的地方是二进制转换。典型案例：VMware、Virtualbox，Virtual PC，KVM-x86\n\n\n\nFull Virtualization\nStrong&amp;Weak\n\n\n\nGuest OS无需修改\n✔️\n\n\n用户体验\n✔️\n\n\n移植迁移\n✔️\n\n\n性能效率\n❌\n\n\n2.1.1 KVMKVM是一个基于Linux内核的虚拟化技术，可以直接将Linux内核转换为Hypervisor。Linux内核能够直接管理虚拟机，直接调用Linux内核中的内存管理、进程管理子系统来管理虚拟机。组成：由处于内核态的KVM模块和用户态的QEMU两部分组成\n\nKVM内核模块：现在是Linux kernel的一个模块，主要包括KVM虚拟化核心模块KVM.ko，以及硬件相关的KVM_intel或KVM_AMD模块；主要负责虚拟机的创建、CPU与内存虚拟化，虚拟内存分配与管理、vCPU寄存器读写等。\nQEMU设备模拟：实现I&#x2F;O设备虚拟化，与KVM内核交互。由KVM内核与QEMU相互配合实现虚拟机的管理。KVM会复用部分Linux内核的能力，如进程管理调度、设备驱动，内存管理等。\n\nKVM工作原理：KVM 模块让Linux 主机成为一个虚拟机监视&#x2F;管理器（VMM)，在KVM体系中，每一个Gust OS都是作为一个标准的linux进程，都可以使用linux进程管理命令管理。KVM中三种模式：\n\n客户模式（Guest Mode）VM运行在这个模式，执行Guest非I&#x2F;O操作指令。\n用户模式（User Mode）QEMU运行在这个模式，实现I&#x2F;O模拟与管理。\n内核模式（Kernel Mode）KVM运行在这个模式，实现模式的切换（VM Exit&#x2F;VM Entry），执行特权与敏感指令。\n\nQEMU通过ioctl发出KVM_CREATE_VM 指令，创建了一个VM后，QEMU需要需要发送一些命令给VM，如KVM_CREATE_VCPU。这些命令当然也是通过ioctl发送的，用户程序中用ioctl发送KVM_CREATE_VM得到的返回值就是新创建的VM对应的fd(kvm_vm)，fd是创建的指向特定虚拟机实例的文件描述符，之后利用这个fd发送命令给VM进行访问控制。![image.png].&#x2F;%E8%99%9A%E6%8B%9F%E5%8C%96&#x2F;4.png)虚拟管理器（Virtual machine monitor）：支持一台计算机执行多个完全相同的环境，与其他计算机隔离操作，Vmm是底层对上虚拟机的管理与支持，早期的虚拟机必须先在系统上安装虚拟机操作软件，在安装系统和应用。目前主流的cpu都做了硬件支持，大多数的Vmm直接装在裸机上，极大提升了虚拟化环境的性能。\n2.2 半虚拟化半虚拟化的核心是为了解决全虚拟化效率不高的问题，让宿主机操作系统知道是在虚拟机上运行，因此物理机执行的一些指令就会变成其他方式来执行，这就需要修改宿主机内核代码来实现，或者将Hypervisor直接安装在物理机上，多个Hypervisor上运行，定制一个特殊的Linux系统。半虚拟化也是利用Hypervisor来实现对底层硬件的共享访问，由于定制了一个特殊的Linux系统，这就使得宿主机的操作系统能够更契合的实现虚拟化。典型案例：Xen、Vmware ESXI 、微软Hyper-v\n\n\n\nPara Virtualization\nStrong&amp;Weak\n\n\n\nGuest OS需要修改\n❌\n\n\n性能效率\n✔️\n\n\n用户体验\n❌\n\n\n维护升级\n❌\n\n\n2.2.1 XenXen架构直接把操作系统内核改了，把OS改成一个轻量级的Hypervisor在里面运行一个管理所有资源调度的Domain0组成：由Xen Hypervisor（虚拟化层）、Domain0（管理主机）、DomainU（用户虚拟机）\n\nXen架构：各Domain之间对共享区域的访问和映射必须通过Hypervisor授权，安全性更高；\nKvm架构：虚拟机之间与宿主机之间对共享区域的访问和映射无需Hypervisor授权，使用Linux裸金属内核，访问路径较短，无性能损耗；\n\n2.3 硬件辅助虚拟化Intel&#x2F;AMD等硬件厂商通过对硬件的改造来支持虚拟化技术，硬件辅助虚拟化技术（Hardware Assisted Virtualization）常用于优化全虚拟化和半虚拟化产品，最典型的例子VMware Workstation，他虽然属于全虚拟化，但在后续版本引入硬件虚拟化技术，如Intel的VT-x和AMD的AMD-V。现在市面上所有的全虚拟化和半虚拟化产品基本上都支持硬件辅助虚拟化。\n三、虚拟化架构3.1 寄居虚拟化寄居虚拟化指在宿主机操作系统安装和运行虚拟化程序，依赖于宿主机操作系统对设备的支持和管理。特点：\n\n简单易于实现，由Host OS管理底层物力资源，由Hypervisor提供虚拟化功能；\n安装和运行应用程序以来于主机操作系统对设备支持；\n有两层OS，管理开销较大，性能损耗严重；\n虚拟机对各种物理设备的调用，都通过虚拟化层和宿主机的OS一起协调才能完成；\n\n典型案例：Vmware Workstation、VirtualBox等\n3.2 裸金属虚拟化直接将VMM安装在硬件设备上，VMM在这种模式下又叫做Hypervisor，通过Hypervisor直接管理底层物理资源，虚拟相应的操作。特点：\n\n不依赖操作系统，直接在硬件上安装虚拟化软件；\n支持多种操作系统，多种应用；\n通过虚拟层内核和服务器控制台进行管理；\n需要对虚拟化层的内核进行开发；\n\n典型案例：VMware ESX、Xen、华为FusionSphere\n3.3 混合虚拟化将一个内核模块加入到宿主机操作系统中，内核拥有虚拟化能力协调虚拟机和宿主机操作系统之间的物理硬件资源调用。特点：\n\n相对于寄居虚拟化架构，性能高\n相对于裸金属虚拟化架构，不需要开发内核\n支持多种操作系统\n需要底层硬件支持虚拟化拓展功能\n\n典型案例：Redhat KVM\n","categories":["Cloud"],"tags":["Linux and cloud"]},{"title":"iTwin.js 开发实践 - 绘制功能","url":"/2022/04/25/iTwin.js%20%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%20-%20%E7%BB%98%E5%88%B6%E5%8A%9F%E8%83%BD/","content":"描述：实现在视图中绘制图形，可以是点、线、面、也可以是三维实体（长方体、球、柱、锥）\n通过定义装饰器相关类，从Decorator类派生\nclass ShowLineTool implements Decorator &#123;&#125;\n实现Decorator方法\ndecorate(context: DecorateContext): void &#123;&#125;\n1.指定坐标点生成折线\n\n指定目标点坐标\n\n[Point3d ](https://www.itwinjs.org/reference/geometry-core/cartesiangeometry/point3d/)：以x,y,z为属性的三维点\n//指点目标点坐标    private _points: Point3d[] = [        new Point3d(0, 0, 0),        new Point3d(1, 1, 1),        new Point3d(2, 5, 2),        new Point3d(3, 6, 3)    ];\n\n\n创建装饰器GraphicBuilder，定义线性、颜色、线宽等参数\n\ncreateGraphicBuilder：创建一个生成RenderGraphic的builder，适合在此Viewport中进行渲染。setSymbology ：设置此builder的参数如：颜色、线性、线宽等。随后添加的任何新的几何体都将使用指定的参数绘制。addLineString：将一个3D线元素添加到builder中。addDecorationFromBuilder：在提供的builder上调用GraphicBuilder.finish以获得一个RenderGraphic，然后将该图形添加到相应的Decorations列表中。\nconst builder = context.createGraphicBuilder(GraphicType.WorldDecoration);builder.setSymbology(ColorDef.green, ColorDef.green, 6, LinePixels.Solid);builder.addLineString(this._points);context.addDecorationFromBuilder(builder);\n\n\n实现showLine方法，对ShowLineTool初始化，并在初始化过后执行addDecorator方法，把上文创建的builder绘制到当前视图中。\n\naddDecorator：添加一个新的装饰器，将Decorations显示在活动视图中。\npublic static showLine()&#123;      if(!ShowLineTool.draw)&#123;          ShowLineTool.draw = new ShowLineTool();      &#125;            if(!ShowLineTool._isLoad)&#123;          IModelApp.viewManager.addDecorator(ShowLineTool.draw);      \t\tShowLineTool._isLoad =  true;      &#125;  &#125;\n\n\n在前端页面中添加该点击事件，直接调用即可。const showLine = () =&gt; &#123;  ShowLineTool.showLine();&#125;;\n\n装饰器，实现各种自定义的效果，不是在三维模型中创建，是显示在三维模型的viewport中。\n2.鼠标取坐标点生成折线描述：通过鼠标拾取视图的中坐标点，生成相应的折线类路径。支持精确捕捉，与Microstation系列建模软件相同操作。\n\n\n实现DrawLineTool类继承自InputCollector\n\n定义一个toolId获取这个工具类的toolId字符串。这个字符串用于在ToolRegistry中识别该工具，并用于从当前的区域设置中对keyin、描述等进行本地化。ToolRegistry：持有一个toolIds和它们相应的Tool类之间的映射。这提供了一种机制，可以通过它们的toolId来寻找工具，同时也提供了一种方法来迭代可用的工具集。\nexport class DrawLineTool extends InputCollector &#123;        public static toolId = &quot;ITwinWebApp.DrawLineTool&quot;;  \t\t\t//开启精确捕捉        onPostInstall() &#123;            super.onPostInstall();            IModelApp.accuSnap.enableSnap(true);        &#125;    &#125;\n实现添加坐标点的方法\nprivate locPoint(pt: Point3d) &#123;    this._points.push(pt);&#125;public static addPoint(pt: Point3d) &#123;    if (!ShowLineTool.draw) &#123;        ShowLineTool.draw = new ShowLineTool();    &#125;    ShowLineTool.draw.locPoint(pt);&#125;\n通过鼠标点击事件拾取坐标点，并将拾取坐标点添加到数组中，使用ShowLineTool.showLine()展示出来\nasync onDataButtonDown(_ev: BeButtonEvent): Promise&lt;EventHandled&gt; &#123;      ShowLineTool.addPoint(_loc);      ShowLineTool.showLine();      return EventHandled.No;  &#125;  async onResetButtonUp(_ev: BeButtonEvent): Promise&lt;EventHandled&gt; &#123;      this.exitTool();      return EventHandled.No;  &#125;  public onRestartTool(): void &#123;      this.exitTool();  &#125;\n在startup()执行时注册工具\nconst toolNamespace = IModelApp.i18n.registerNamespace(&quot;SVTTools&quot;);IModelApp.tools.register(DrawLineTool , toolNamespace);\n在前端页面增加该点击事件，直接调用即可\nconst drawLine = () =&gt; &#123; IModelApp.tools.run(DrawLineTool.toolId, IModelApp.viewManager.selectedView);&#125;\n","categories":["computer graphics"],"tags":["iTwin Platform"]},{"title":"iTwin.js 理论基础 - Unity引擎","url":"/2022/04/16/iTwin.js%20%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%20-%20Unity%E5%BC%95%E6%93%8E/","content":"本文展示一个Unity应用程序中使用IPC与iTwin.js融合的例子，演示如何将一个iModel在Unity应用程序中显示。\n部署环境1.Unity\n安装Unity 2019.1以上版本（测试使用Unity Personal免费版即可）\n2.iTwin Demo\n\n下载示例代码\nNode 12\n\n3.Unity Editor\n本示例中采用Unity Editor版本为2019.1.3f1，其他版本也可使用但未经测试，通过Hub下载的Editor同时会将对应版本的Visual Studio同步安装。\n使用教程1.下载Github代码\n打开shell执行：\ngit clone https://github.com/iTwin/imodel-unity-example.gitcd imodel-unity-examplecd node/npm installnpm run buildnpm start\n\n2.运行Unity\n\n打开Unity Hub，点击**”Open”按钮**，选择下载代码中的unity文件夹，等待编译。\n\n\n\n进入如下页面，点击屏幕中部的**”Play”按钮**即可\n\n注意：\n\n左下角Console控制台有时会提示Rebuilding Library because the asset database could not be found!，需要关闭当前项目，重新打开。\n首次导入项目需要注意Hierarchy窗口中是否包含MainLoop脚本文件。该脚本文件为程序主入口，如果缺失则无法显示模型也不打印任何log，如缺失需要从选项卡中**”File-Open Scene”**重新加载。\nScene路径为：imodel-unity-example\\unity\\Assets\\Bentley\\Scenes\n\n3.使用视频\n# 工作机制\n1. Node.js Server与iTwin.js\nNode.js服务器使用imodeljs-backend包及其依赖项来打开一个指定的Snapshot iModel。无论这个iMode的大小，每次打开都会加载最少的数据量。\n2.Node.js Server与Unity\n在此示例中，Unity 应用程序通过WebSocket连接到同一台计算机上的进程，它也可以轻松连接到云中或本地网络上的单独计算机。此模式常用于流式传输到 Microsoft HoloLens 或 Oculus Quest 等独立设备。\n3.进程与协议缓冲区消息通信\nNode.js服务器与Unity应用程序之间的通信是通过使用Google协议缓冲区编码的消息进行的。协议缓冲区是一种广泛有用且高效的格式，具有出色的工具和代码生成功能，适用于多种语言。修改 IModelRpc.proto 时，将为 Node.js 服务器和 Unity 应用程序自动生成新绑定。IModelRpc.proto 分为”请求”和”回复”，Unity 应用程序发出请求，Node.js服务器发出回复。由于协议缓冲区消息不是自描述的，因此每个进程在解析时都需要知道消息类型。 \n 4.数据传输\n\n元素图形和数据按需流式传输，iModel上的空间查询被用来请求基于Unity摄像机可见的图形。首先发送体积最大的元素，随着相机的移动，不断请求新的图形。选择元素时，按需加载元素属性。\n5.加载不同iModel\n\n加载Snapshot iModel，直接替换imodel-unity-example\\node路径下的.bim文件\n加载iModelhub iModel，在 IModelHubDownload.ts 中进行编辑，将 contextId 和 iModelId进行补充为对应的Id，然后运行npm run start-from-hub\n\n6.AR,VR或者其他平台\n该示例旨在生成桌面可执行文件，因为它是开发人员最通用且可普遍访问的平台。同时，项目代码及其依赖项适用于 Unity 支持的大多数平台。Bentley开发人员已经将此示例部署到Oculus Rift，HTC Vive，Oculus Quest，Microsoft HoloLens和其他设备上。\n7.性能提升\n此示例默认为 iModel 中的每个元素创建一个 Unity 游戏对象。这样做是为了简化代码并使其更易于扩展，但对于性能而言不是最佳。\n","categories":["computer graphics"],"tags":["iTwin Platform"]},{"title":"iTwin.js 理论基础 - Unreal引擎","url":"/2022/04/13/iTwin.js%20%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%20-%20Unreal%E5%BC%95%E6%93%8E/","content":"使用iTwin Exporter for Datasmith应用程序可以将iModel数据导出Datasmith格式，并将其导入Unreal Engine中。\n部署环境1.Unreal Engine\n安装Unreal Engine 4.26.1或更高版本，在iTwin Exporter for Datasmith应用程序之前安装Unreal引擎，因为该应用程序需要一些Unreal引擎的组件。\n2.iTwin Exporter for Datasmith\n通过单击此处的”立即下载”来下载安装程序，然后运行安装程序将完成安装。\n3.Visual Studio\n安装 Visual Studio，并安装了”使用 C++进行游戏开发”和”.NET 桌面开发”工作负载。\n使用教程1.选择iModel\n适用于 Datasmith 的 iTwin 导出程序将打开登录页面。点击”登录”按钮，系统将提示您通过默认浏览器登录。这将带您进入最近项目的iModel选择屏幕。\n\n要访问其他项目，请选择标题中的项目下拉列表，然后选择一个最近的项目，或单击”查看我的所有项目“以打开**”项目选择”屏幕**。\n\n\n2.将iModel导出为Datasmith\n选择项目并找到 iModel 后，您可以点按”导出”按钮立即执行导出。\n\n这将打开**”高级导出”对话框，您可以从中切换“合并所有网格”切换，然后按对话框底部的“确认导出”按钮**。\n\n注意：上图中的（x，y，z）并非模型坐标，与MS中的ACS坐标不同。此值为偏移量，通过添加（x，y，z）的矢量来偏移几何图形。默认iModel在Unreal space的中心点是（0，0，0）。\n\n只需按下按钮，然后使用系统的”保存文件”对话框，即可选择以什么名称以及在哪里保存生成的 datasmith 内容。然后等待导出完成，这表示出现绿色成功消息。\n您也可以单击 iModel 卡片的图像或其**”查看按钮”**进入查看器，并可以使用左上角水平工具栏中最左侧的按钮运行组合网格导出。\n\n\n2.1 导出结果\n导出完成后，您应该在所选的导出位置中拥有一个命名的文件，例如，一个与前缀同名的文件夹。\n3. 导入iModel至Unreal引擎\n3.1 在Unreal引擎中创建项目我们建议使用”建筑，工程和施工”模板，以便启用所需的Datasmith导入器插件。如果您选择不这样做，则需要在项目的设置中自行启用该插件。Unreal指南。\n3.2 安装iTwin Unreal Datasmith插件现在，我们可以导航回选择屏幕，并使用插件安装程序按钮将iTwin虚幻Datasmith插件安装到我们的虚幻项目中。点击左上角的”主页”按钮，或使用项目下拉列表，然后按”查看我的所有项目”选项导航回”项目选择”屏幕。在选择屏幕中，您可以按应用程序底部的蓝色”安装插件”按钮，然后在文件对话框中找到属于您创建的Unreal项目的文件。只需选择该文件，插件就会安装到该项目中。确保关闭并重新打开虚幻项目（如果已打开）。自安装以来首次打开项目时，它将提示重新构建插件。它是为不同的引擎版本设计的，但你可以忽略这一点，并告诉它继续构建。如果重建失败，请确保您已满足所有先决条件，因为如果您使用的是不受支持的虚幻引擎版本或未正确安装所需的Visual Studio工作负载，则重建可能会失败。\n3.3 导入iModel在Unreal引擎编辑器中，使用Datasmith导入按钮打开文件系统对话框，然后选择您的文件以将其导入到场景中。选择一个文件夹，将Datasmith导入的内容放入内容浏览器中，然后更改您需要的任何其他导入设置，例如，如果您只使用动态光源来照亮虚幻引擎中的场景，则禁用光照贴图UV生成。然后只需等待导入过程完成即可。\n4. Unreal Engine(以下均为UE4引擎使用方法，请参阅UE4教学文档)Unreal在内容浏览器中打开，然后将材质拖放到静态网格体上。我们拖拽并放下一些玻璃、混凝土、金属、草、木头和鹅卵石到我们的场景中，看到一些高保真材料。我们的示例场景尤其受益于过滤掉树木和草地模型，并用更逼真或动画的模型替换它们，但这是虚幻项目中需要探索的东西。\n","categories":["computer graphics"],"tags":["iTwin Platform"]},{"title":"iTwin.js 理论基础 - PRC接口","url":"/2022/04/12/iTwin.js%20%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%20-%20RPC%E6%8E%A5%E5%8F%A3/","content":"RpcInterface\n本文会对iTwin.js 中的 RPC 通信进行说明。\nOverview\niTwin.js 应用程序的功能通常在不同的组件中实现，这些组件可能在不同的进程中运行。这些组件通过接口进行通信。这些接口可以实现为 Rpc 或 Ipc。对于Web应用程序，iTwin.js使用RpcInterfaces。上图显示了一个应用程序的前端从一些后端请求操作。客户端和服务器这两个词指明了RpcInterface的两个角色：\n\nclient – 运行在前端的代码，并调用RpcInterface的方法。\nserver – 在后端运行并实现 RpcInterface 的代码。\n\n从 RpcInterface 派生的类定义了一组由服务器实现的操作，可从客户端调用。如图所示，客户端和服务器使用 RpcManager 来管理可用的 Rpc 接口。RpcManager 在客户端公开转发 RPC 请求。另一端，RpcManager 使用服务器调度机制将请求中继到服务器中的实现。介于两者之间的是一种传输机制，该机制通过适当的通信通道将数据从客户端传递到服务器。传输机制封装在运行时应用的配置中。一个典型的应用程序前端将使用多个远程组件。同样，服务器可以公开多个组件。例如，应用前端可能需要两个接口：接口 1 和接口 2。在此示例中，两者都在后端 A 中实现。应用前端同样可以轻松地与多个后端配合使用，以获取所需的服务。RpcInterface 的配置参数之一是提供它的后端的标识。例如，假设前端还需要使用接口 3，该接口由后端 B 提供。前端用于后端 B 的 RPC 传输配置可能与它用于后端 A 的配置不同。事实上，这是常见的情况。如果后端 A 是应用自己的后端，而后端 B 是远程服务，则应用将使用与其自己的 A 配置匹配的 RPC 配置，而对 B 使用 Web 配置。如上所述，RPC 接口的客户端可以是前端代码，也可以是后端代码。这意味着后端可以调用其他后端的服务。换句话说，后端可以同时是服务器和客户端。后端通过在 RpcManager 上调用 initializeImpl 方法来配置它实现的 RpcInterfaces，并通过调用 initializeClient 来配置它使用的 RpcInterfaces。例如，假设后端 B 需要后端 C 的服务。\nRpc vs. Ipc\n在 iTwin.js中，RPC（远程过程调用）和 IPC（进程间通信）都是在浏览器中运行的前端进程和在 Node.js 下运行的后端进程之间进行通信的机制。两者都可用于连接驻留在同一台计算机或通过网络连接的不同计算机上的进程。\nRPC\nRPC（在iTwin.js中实现）用于前端和后端松散耦合的情况。在此模式下，单个后端可能为多个前端提供服务，并且多个后端可以为来自同一前端的请求提供服务。对于Web应用程序来说，这是非常普遍的，这也是当今大部分Web体系结构被设计为无状态的原因。通过RPC，从前端到后端的每个请求都必须包含授权凭据、路由信息等。这可能会给通信增加一些开销，但这也是实现横向拓展的原因。因此，通常对于Web应用程序，这是一个很好的权衡。RPC 的松散耦合假设意味着严格遵守 API 语义版本兼容性，因为前端和后端组件是独立部署和修订的。RPC 初始化始终涉及验证版本兼容性要求。一般来说，iTwin.js中的RPC是通过HTTP实现的。这意味着 RPC 通信必须始终由前端发起。由于协议的无状态性质，这是完全可以的，因为后端不会发送任何可以发送到特定前端的内容。\nIPC\nIPC（在iTwin.js中实现）用于前端和后端紧密耦合的情况。在此模式下，单个前端进程通过 IpcSocket api 以一对一的关系与单个后端进程配对。在iTwin.js术语中，这意味着IModelApp与IModelHost（有时称为”专用”后端）配对，并且它们的生命周期是一致的。每个都可以假设另一个可以在会话过程中保存明确的状态信息。对于编辑 iModel 的应用程序，这种关系非常有用。使用 IPC，经过一些初始验证后，消息可以双向发送，而不会产生任何开销，因为连接是直接且明确的。这使得 IPC 的实现效率更高，并且可以直接实现。通常，iTwin.js中的IPC是作为套接字实现的 - 通过Electron的ipc实现桌面应用程序，或通过WebSockets实现Web或移动应用程序。IPC 的优点是后端可以主动向其前端发送消息。IpcSocket api不要求前端和后端进程驻留在同一台计算机上，只是它们的生存期是成对的。当已知它们始终位于同一台计算机上时，我们将其称为本机应用程序。\n","categories":["computer graphics"],"tags":["iTwin Platform"]},{"title":"iTwin.js 理论基础 - 法线","url":"/2022/04/09/iTwin.js%20%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%20-%E6%B3%95%E7%BA%BF/","content":"Using Surface normals\nCoarse facets on a smooth surface\n下图是光滑曲面的贴图，表现为4✖6的切面网格，并画出了所有的切面边缘：下面是相同切面的两个着色图像，没有显示边缘。由于阴影差异，左侧的边缘仍然清晰可见。刻面的块状效果非常明显。但是在右边，表面看起来更光滑。仔细观察块状版本，每个切面都有一个单一的灰度阴影。由于从一个块状灰度到下一个块状灰度的跳跃，边缘是清晰可见的。但在光滑的版本中，灰度在每个区块内平滑变化，而在边缘没有变化。这种差异是由于使用了面的法线–指向面外的向量。这是一张特写，显示了(a)整个左下角的切面和(b)右边和上面的小部分相邻。在顶点附近的角落里，也出现了一些短的黄线，指向远离切面的地方。仔细观察完整的左下角切面–你可以看到这4条黄线都正好垂直于切面的平面。但是，来自相邻刻面角落的非常近的线条却以稍微不同的角度倾斜，因为相邻刻面在不同的平面上。这里是同一角的特写，是更平滑的图像。在这种情况下，”靠近每个顶点 “的黄线是与同一顶点的邻居平行的，而不是与同一面上远处的其他人平行。这个方向最好是取自真正的分析性原始面（围绕一条线旋转的圆弧）。如果不知道原始面的方程，使用2个或4个面的平均值也很好。在任何一种情况下，图形软件和硬件都会使用这些法线来估计整个面反射的光线的平滑变化，从而产生巨大的图像质量改善。\nIntroducing sharp interior edges\n此处是相同数量的刻面，具有相同的网格结构，但上部 4 个刻面向下折叠到一个平面上，该平面与光滑表面的其余部分明显不同。当没有绘制边时，我们希望看到下部 - 弯曲的部分 - 像以前一样平滑地显示。平坦部分的内部全部位于平面中，并且它应该在连接弯曲部分的急转弯边缘处具有明显的边缘。这里有三张没有画边的图片：\n\n左侧图形显示刻面之间有清晰可见的断点；\n中间图形整体显示平滑；\n右侧图形在弯曲部分是光滑的，有清晰的断点，在共面内是平的。\n\n同样，显示变化是由于在每个刻面的每个角上呈现的表面法线。\n\n左边图形每个面的角都得到该面自身平面的法线，当然在该顶点与其他面有一个明显的角度。\n中间图形每个顶点附近的所有角落都得到一个来自所有（2或4个）入射面的平均法线。在光滑部分，这很完美。但是在折叠边缘，单一的法线对于任何一方都不是正确的。\n右侧图形法线从折叠平面或曲面正确拉出。因此，在折叠的每个顶点处都有多个不同的法线值。\n\n这种共享共同边缘的混合效果显示在机械模型中普遍存在。\n","categories":["computer graphics"],"tags":["iTwin Platform"]},{"title":"iTwin.js 理论基础 - 曲线","url":"/2022/04/07/iTwin.js%20%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%20-%20%E6%9B%B2%E7%BA%BF/","content":"Curve Primitives\nlineSegment\n线段是一条直线的一部分\nJson Fragment: [&#123;&quot;lineSegment&quot;:[[0,0,0], [3,0,0]]&#125;\ntypescript object:const myLineSegment = LineSegment.create (Point3d.create (1,2,3), Point3d.create(6,4,2));\nA = start pointB = end pointf = fraction varying from 0 to 1Point X(f) at fractional position f along the lineSegment is  X(f) = (1-f) * A + f * B\n\nlineString\nLineString是一个点的数组，这些点由直线连接\nJson Fragment: \nTypescript object:const myLineString = LineString.create ([point0, point1, point2 ....]);\n\n \narcs (circular and elliptic)圆弧基元是圆弧或椭圆弧的一部分。一个完整的椭圆弧的方程需要一个中心点和两个矢量。部分圆弧的起点和终点由两个角度控制。圆形和椭圆形情况的等式形式是相同的，判断给定的弧是否为圆形需要检查矢量坐标。将角度映射到坐标到椭圆（或圆形）弧周围点的描边方程是\nC = center pointU = vector from center point to 0-degree pointV = vector from center point to 90-degree point.theta(θ) = angleX(theta) = C + cos (theta * U + sin(theta) * V\nTrue Circles\n\n如果U和V向量垂直且长度_相同_，则这是一个真正的圆。\n在下面的两个圆中，向量U、V和的长度相同且相互垂直。\n对于左边的圆，向量U、V的和恰好在全局 x 和 y 方向上。\n对于右边的圆，向量U、V和仍然是相同的长度且垂直，但都旋转远离全局 x 和 y的位置。\n当圆弧条件为真时，方程中使用的角度是矢量和从中心到UX(theta)的矢量之间的实际物理角度。\n\n\nEllipse\n如果和向量U和向量V有长度不同，则是椭圆。由于本文重点介绍iTwin.js绘制弧的机制，对数学方面的定义不做过多解释。\nAngular limits\n要绘制一个不是完整的圆或椭圆的弧线，只需将theta范围限制在0到360度以外都可。\ntheta0 = angular start pointtheta1 = angular and pointf = fraction varying from 0 to 1theta(f) = (1-f) * theta0 + f * theta1    Point X(f) at fractional position f along the arc isX(f) = C + cos (theta(f)) * U + sin(theta(f)) * V\n\n\n角度θ0和θ1可以是负数，并且可以在360度之外。\n角度θ1可以小于θ0\n\nExamples of arc sweep\n\n\n\nstart and end angles\nCCW signed sweep angle\nimage\n\n\n\n(0 to 360)\n360\n\n\n\n(0 to 135)\n135\n\n\n\n(270 to 495)\n225\n\n\n\n(90 to 270)\n180\n\n\n\n(90 to 405)\n315\n\n\n\nExamples with json fragments \nbspline curves\nReferences\n","categories":["computer graphics"],"tags":["iTwin Platform"]},{"title":"iTwin.js 理论基础 - Lod优化","url":"/2022/04/05/iTwin.js%20%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%20-%20LOD%E4%BC%98%E5%8C%96/","content":"\niModel tilesiTwin.js有能力对任何标准的3d tile格式进行流化和渲染，iTwin.js也是通过这种格式来加载实景模型和地形数据。但是，iTwin.js后端生成的用于可视化的内容使用称为”iMdl”（表示”iModel”）的非标准格式，该格式针对iTwin.js提供的独特功能进行了优化。Level of detail广泛用于3MX、3SM、Cesium 3D Tiles、ESRI i3s、DGN、FBX、OBJ、LODTreeExport。\n\nLevel of detail每块Tile包含的图形的详细程度只适合于屏幕上的特定尺寸。例如，下图是房子的iModel的根（最低分辨率）Tile显示效果。当Tile的显示尺寸与屏幕像素差不多时，我们视野中呈现出细节水平的显示效果就会很合适。但是，如果我们放大，使其拥有更多的屏幕占比，我们会发现看似圆形的窗户和门把手不再显得很圆，更趋近于多边形。Tile的详细程度用Tile的 chord tolerance（弦容差）来表示。也就是说，可以用来接近曲线的最大弦长。一般来说，我们希望弦长（以米为单位）大致相当于屏幕空间中一个像素的大小。当我们放大时，和弦会变得比一个像素大，因此可以感觉到，所以我们必须要求新的Tile具有更高的细节水平（即更小的和弦公差）。弦容差（有时称为弦误差或垂度误差）定义了细分曲面上任何点距原始曲面上对应点的最大距离。降低该参数的值会使细分曲面更接近原始曲面，进而生成更多小三角形，提升曲面平滑度。在下面的图片中，绿色和蓝色的矩形代表更高分辨率的Tile，它们是根Tile的直接子代。这些Tile中的圆看起来比根部瓦片中的圆要圆得多。![image.png].&#x2F;iTwin.js%20%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%20-%20LOD%E4%BC%98%E5%8C%96&#x2F;level5.png)在某些情况下，整个元素可能小于一个像素，在这种情况下，它们可能被完全从Tile中省略。为了说明这一点，我们制作一个由相同的房屋组成的社区，其根Tile看起来像这样。如果我们放大这块Tile中的一扇门，我们会注意到除了一些明显的非圆形的圆圈，门把手完全不见了。这就是我们要说明的一个问题，我们只需要在适当的屏幕尺寸下显示这个Tile。事实上，这是一个重要的优化，限制了每个Tile中三角形的数量。但是如果我们放大，渲染器就会请求包括门把手在内的更高分辨率的子Tile。LOD优化的关键是对包含较大空间体积的Tile提供较低的详细程度，因此每个Tile应包含大致相同数量的三角形。由于屏幕上显示的图块数量应保持相对恒定，因此无论当前正在查看模型的哪个部分，在任何特定时间显示的三角形数量也应保持相对恒定。当用户放大查看整个模型时，模型微小的细节被省略或简化，这种级别的变化很难被肉眼识别。限制三角形的数量使我们能够很好的处理GPU资源调度并将任何规模的模型可视化。\nBatching除了限制提交到 GPU 的三角形数量外，Tile还会最大限度地减少”绘制调用”的数量。绘制调用是发送到 GPU 的离散命令。例如，”绘制这一堆三角形”。例如，假设我们要绘制一个由 1000 个三角形组成的场景。我们可以提交 10 个绘制调用，每个调用由 100 个三角形组成，或者 1 个绘制调用由 1000 个三角形组成。在后一种情况下，现代图形硬件的执行效率要高得多。iModels由元素组成。在上面的示例房屋 iModel 中，每个窗户、门、墙壁、门把手和屋顶部分都是一个单独的元素。传统的渲染器将为每个元素生成一个三角形网格，并将每个网格作为单独的绘制调用提交。在一个由数千或数百万个元素组成的真实iModel中，这将产生太多的绘制调用，无法维持交互式帧速率。iTwin.js渲染机制不渲染元素 ，它渲染Tile。考虑到与Tile体积相交的元素集合，我们努力将它们全部批处理成尽可能少的网格，最理想情况下是一个。这是通过合并元素网格来实现的，然后通过一些策略区分合并网格内的顶点来实现的，包括：\n\n颜色表：生成网格中每种唯一颜色的查找表。每个顶点（而不是指定其 RGBA 颜色）只是在表中指定其 8 位或 16 位整数索引。\n材质图集：生成网格中每个唯一 RenderMaterial 的查找表。每个顶点指定表中相应材料的 8 位整数索引，而不是为每个材料生成单独的网格。\n\n并不可能为每块Tile生成一个网格。例如，不透明的网格不能与透明的网格分批生成，因为它们必须在不同的通道中渲染。\nFeature tables每块Tile都嵌入了一个FeatureTable，描述了Tile中存在的每个独特的特性–即元素Id、子类别Id和GeometryClass的组合。Tile中的每个顶点都指定其来源于元素的24位整数索引。当渲染器想要查询某个区域（比如说，在鼠标光标位置）的哪些特征是可见的，它就会渲染与该区域相交的Tile，输出元素id，然后查询特征表以获得相应的特征。FeatureTable还支持高效的重符号化。一个查询表是由当前的FeatureOverrides构建的。顶点着色器使用其特征id索引到此表中，并应用相应的覆盖。\nTile tree structure标准的3d Tile集通常是静态的：它们由一组有限的预先发布的tile组成，这些瓦片按已知的层次结构组织。例如，Bentley ContextCapture 发布了一组Tile和一个描述其结构的 JSON 文件。显示此类Tile集只需查阅 JSON 文件并下载相应的Tile。iModel Tile是不同的。由于用户可以在视图中任意放大，因此Tile集在理论上是无限的。为模型生成一组详尽的Tile是完全不切实际的。所以，在有人请求 iModel Tile之前，iModel Tile并不存在，此时它由 iTwin.js后端生成（然后选择性地缓存以供后续重用）。此外，无法在浏览模型之前完全了解Tile Tree的结构，因为Tile只能在浏览模型的过程中动态创建。例如，一个特定Tile 的空间体积可能完全没有元素，因此该Tile 是空的，并且没有子Tile 。或者，Tile 的体积可能仅包含未弯曲的几何图形，在这种情况下，可能没有必要生成子Tile 来优化它，因为不会达到更高的细节水平。Tile Tree结构的这些特征和其他功能只能通过实际生成Tile 来确定。\nRefinement strategies当我们希望看到的几何图形有着更高的分辨率，这其实就是优化Tile的过程 。Tile 遵循”空间相干性”。也就是说，Tile 的子Tile 的体积必须完全包含在父Tile 的体积中。iTwin.js 采用两种Tile 优化策略：\n\n细分法：这是迄今为止最常见的3d tiles策略，具有多种方法，包括四叉树，八字树和k-d树。所有这些都是将父Tile再细分为较小的子卷。对于三维模型，iTwin.js 应用细分来生成 8 个子卷。父Tile 的体积在其最长轴上分成两半；然后将产生的两半体积在其最长的轴上被分割；最后，生成的 4 个子卷再次拆分到其最长轴上。此过程如下图所示。（对于 2D 模型，仅生成 4 个而不是 8 个子卷）。\n\n\n\n放大法：放大法不是将Tile细分为多个较小的子Tile，而是生成与父Tile大小相同大小的单个子Tile，但其细节水平是其两倍。这种方法有助于降低深度复杂性，即当用户放大时，必须要求更多的Tile来显示延伸到屏幕上的几何图形。但是，这个方法必须要谨慎的使用，因为在不减少Tile体积的情况下过多地增加细节水平会引入浮点精度错误，从而导致图形伪影的出现。\n\n \n\n### Determining the structure\n\n\n要生成一个Tile，iTwin.js 后端必须查询其边界相交的所有几何元素。然后，它遍历每个元素的几何流。任何相对于Tile的弦容差足够小的元素或几何基元都将被省略。否则，几何图形将转换为三角网格（或折线或点字符串）并被添加到Tile的批处理网格中。最后，特征表和一些元数据将嵌入到切片中。（注意：这是对Tile生成过程的极其简化的描述，省略了许多细节）Tile生成过程生成的元数据是发现Tile树结构的关键。每个Tile的元数据记录包括：\n\n图块的图形中是否省略了任何足够小的元素或几何图形位；\n在Tile的体积内是否遇到任何弯曲或去掉的几何图形；\n包含Tile内的所有几何图形；\n表明将Tile的哪些子卷确定为完全为空的字段。\n\n在可行的情况下，测试子卷是否与单个刻面和线段相交，而不是与边界框相交；这提高了空子卷检测的准确性。如果有任何几何图形被省略，或者Tile中存在任何弯曲或抽取的几何图形，则我们知道该Tile需要优化（即，它具有子Tile）；否则，LOD将没有实际意义。在此背景下允许我们对观察范围执行更严格的交叉测试，以避免绘制实际上不可见的Tile。在下图中，绿色和蓝色矩形表示每个Tile的内容体积，该体积通常小于（并且永远不会大于）Tile的边界体积：通过空子卷的信息我们能够省略对子Tile的请求，因为我们知道这些子Tile不会生成任何图形。在下图中，绿色矩形表示需要优化的Tile，蓝色矩形表示不需要优化的Tile。缺少矩形表示被标识为完全空的卷，因此不会对这些卷发出Tile请求。请注意，所有绿色矩形都包含弯曲几何图形，并且所有蓝色矩形仅包含未弯曲的几何图形：Tile - 深度 1：Tile - 深度 2：\nOptimizationsiModel tile采用许多优化措施，旨在减小Tile大小（以及扩展的 GPU 内存使用率和下载时间）并提高帧速率，包括：\n\nlookup tables：通常，位置、颜色、法向量等顶点数据作为顶点属性提交到 GPU。相反，iModel Tile将所有顶点数据嵌入到用作lookup tables的单一纹理中；唯一的顶点属性是每个三角形顶点的表中的 24 位索引。同样，另一个lookup tables包含有关网格中每个可见边的信息。这大大减少了冗余，从而减少了Tile。\niModel tile：iTwin.js支持显示网格的边缘。这需要有关每个Tile中包含的边缘的信息，这可能会大大增加每个Tile的大小。如果当前未显示边，iTwin.js 将请求省略边信息的Tile，从而避免不必要的开销，但代价是以后启用边显示时需要请求新Tile。同样，为截面剪切图形、时间轴动画和其他目的生成特殊Tile。\n压缩：采用各种策略来最小化Tile的内存占用，包括位置量化、法向量的八进制编码以及使用 24 位整数作为索引。\n\n","categories":["computer graphics"],"tags":["iTwin Platform"]},{"title":"iTwin.js 理论基础 - 渲染系统","url":"/2022/03/25/iTwin.js%20%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%20-%20%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/","content":"iTwin.js可以实现iModels、实景模型、IoT传感器数据、地图图像和其他数据源的数据加载和渲染，以实现iTwin内容的可视化。iTwin.js渲染系统还支持直接加载装饰器和Tile。渲染系统分为两个部分：\n\n前端运行WebGL的Tile渲染器，负责显示视口的内容；\n后端运行本地Tile生成器，负责根据iModel的内容生成相应的Tile；\n\n在前端和后端之间可以引入一个缓存层，以提供先前生成的Tile；或者后端可以维护自己的内部缓存。本文档主要关注显示系统的前端部分；后端Tile生成器的文档只限于iModel Tile格式的概述。\nConfigurationiTwin.js渲染主要分为两部分：\n\nTileAdmin协调Tiles的请求并管理其生存周期以限制内存消耗。\n渲染系统通过 WebGL 与图形硬件进行通信，以分配 RenderGraphics 和 RenderTextures 等资源，并将视口的内容绘制到屏幕上。\n\nWebGL由于网页的渲染在浏览器环境中运行，因此它在后台使用 WebGL与图形硬件进行通信。然而，WebGL 不会公开供应用程序使用的相关内容。相反，像GraphicBuilder和RenderSystem这样的抽象类提供了更高级的API，用于间接使用WebGL资源。渲染器支持任意数量的视口，所有视口共享单个 WebGL 环境，以减少着色器、纹理和磁贴等资源的重复。视口可以相对彼此自由定位，有无重叠皆可。渲染器将尝试使用 WebGL 2，它提供了比 WebGL 1 更多的功能和更好的性能;但在缺乏对 WebGL 2 支持的设备上将回退到 WebGL 1。在撰写本文时，Safari浏览器终获得了对WebGL 2（在macOS Monterey和iOS 15中）的官方支持，这使得WebGL 2的支持更加普及。尽管如此，渲染器的某些高级功能在某些设备上可能不受支持。请查阅兼容性检查器，以确定您的设备上可能不可用的功能。支持主流的浏览器，包括Firefox，Safari和基于Chrome的浏览器（Chrome，Electron，Brave，Edge等）。在基于Chrome的浏览器中观察到最佳图形性能。不支持 Internet Explorer 和”旧”Edge。\nAlternativesWebGL 仅公开了现代图形硬件的一小部分功能。通过使用 iTwin for Unreal 或 Unity 导出器，分别导出网格以供Unreal 和 Unity 使用，可以生成更多逼真的 iModel 可视化效果。\n\nTile-based renderingiTwin.js渲染系统负责在网络浏览器的限制下，将来自各种不同来源的大量数据可视化。它主要是通过使用Tiles来实现的–一种将大型模型的几何结构划分为一个层次的子卷的机制，每个子卷代表模型几何结构中某一特定细节的一部分。其结果是一个TileTree，可以有效地查询所需的Tile集，以渲染与用户当前所看的空间体积相对应的模型部分，其细节水平适合于当前的观察Frustum和视口分辨率。iTwin.js渲染系统可以广泛的加载来源汇集不同类型的数据：\n\niModels，由iTwin.js后端产生的Tile格式\n标准三维Tile格式的实景网格和点云，例如由Bentley ContextCapture生成的格式；\nOrbitGT格式的点云；\n来自各种来源的地图图像，包括Bing和MapBox；\n来自Cesium ION的世界范围的三维地形网格；\n由OpenStreetMap提供的世界范围的建筑网格；\n由应用程序通过TiledGraphicsProviders提供的任何格式的三维Tile；\n\nCesium的3d tiles标准对一般概念做了很好的概述，同时还提供了一些针对标准3d tiles格式的细节。由iTwin.js后端产生的Tile使用iModelTile格式，它在许多方面与其他格式不同。\nScene creation\n一个空间视图（spatial view）可以聚集任何数量的空间模型，如其ModelSelector所指定。每个模型都与一个TileTree关联，TileTree为该模型提供图形。下面的GIF动画说明了一个办公楼的空间视图如何由四个独立的模型组成：一个提供管道系统，另一个提供结构元素，第三个提供建筑组件，最后是景观。视图也可以包含与现实模型、地图、地形或自定义提供者相关的Tile树。组建场景需要遍历每个Tile树，选择最适合显示的Tile，可能还要排队请求加载更多合适的Tile，最后将Tile渲染到屏幕上。这个过程主要由TileTreeReference.addToScene实现。虽然TileTreeReference的不同实现之间的细节会有所不同，但它通常看起来像下面这样，从根Tile开始。\n\n当该Tile与所查看的体积和应用于视图或模型的任何剪辑体积相交，且该Tile对当前视图来说具有合适的细节水平，首先对该Tile图形进行加载，然后选择该Tile进行显示。\n当该Tile的直系子类图形被加载，选择该子类Tile进行显示。\n当该Tile的直系父类图形被加载，选择该父类Tile进行显示。\n\n所有被选中显示的Tile的图形都被添加到场景图中。然后，渲染器将图形解构为一个有序的渲染命令序列，并将其组织成几个渲染通道。例如，不透明的几何图形在一个通道中被绘制，而透明的几何图形在随后的通道中被绘制。最后，这些命令被提交给GPU，而新的图像被混合到屏幕上。\nTile loadingTile通常在没有图形的情况下无法感知的–它的图形只有在场景创建过程中被选择显示时才会被加载。TileAdmin维护一个Tile内容请求队列。在任何时候，最多可以有N个内容请求；其余的在一个优先级队列中。准确的最大值取决于应用程序的配置；对于Web应用程序，它默认为10，以考虑到HTTP&#x2F;1.1的限制；对于桌面和移动应用程序，它是基于客户端设备的硬件并发性。待处理的请求会在取消时从队列中移除–例如，如果观察范围发生变化，使得Tile的图形不再需要在任何视口中显示。\nResource managementTile图形消耗图形内存，而Tile本身则消耗JavaScript堆内存。Tile在未使用一段时间后会被常规地丢弃，同时丢弃的还有它们的WebGL资源和所有的子孙。整个Tile树在废弃一段时间后（通常是更长时间）也会被丢弃。每个Tile都会跟踪它从WebGL中请求的内存总量。TileAdmin.gpuMemoryLimit可以被配置为对所消耗的图形内存量进行限制；如果Tile所消耗的内存总量超过该限制，那么最近使用最少的Tile的图形将被丢弃，直到满足该限制。Tile本身不会被丢弃；当前在任何视口中被选中显示的任何Tile的图形也不会被丢弃。这个限制需要仔细平衡：限制太低可能会导致对同一Tile内容的过度重复请求，而限制太高则有可能超出客户端的可用图形内存，通常会导致背景内容丢失。\nLighting, materials, and environmentiTwin.js渲染机制是为在一个受限的浏览器环境中可视化大型基础设施数字孪生设计的。逼真的渲染并不是该设计的一部分–产生更逼真的图像所需的许多技术都不支持，或者可以理解为使用WebGL不是一个最优选择。因此，iTwin.js渲染机制提供了各种各样的参数来支持基础设施数字孪生的显示效果。\nLighting and environment视图的光线效果和环境效果通过视图的DisplayStyleState来设定。\n\nLightSettings定义定向、纵向、环境和半球形光源；以及控制镜面、Cel-shadow和Fresnel效果；\nSolarShadowSettings（光线阴影设置）根据给定地点和日期的现实世界的太阳位置产生阴影\nAmbientOcclusion可以模拟阴影；\nEnvironment可以提供一个装饰性的天空盒或天空球；\n\n下面的图片说明了不同的光线设置和环境设置对同一视图的影响。\nMaterialsiModel 中的 RenderMaterialElements 可以存储许多 RenderMaterial 属性供渲染器使用。但是，基于 WebGL 的显示机制目前仅支持以下属性的一小部分：\n\n漫反射颜色和重量\n透明度\n镜面反射颜色、指数和权重\n纹理贴图和权重\n\nClipping and section-cut graphicsiTwin.js渲染机制支持使用”矢量裁剪”在视图中剪除部分几何图形。这对于隔离 iModel 中部分模型、剖面图的可视化和超建模有着非常重要的作用。\nClipping矢量裁剪可以由任意数量的凸形或凹形形状构成。剪切可以应用于场景图的任何级别 - 例如，一个剪辑可以应用于视图的内容，另一个剪辑可以应用于视图中的特定模型，第三个剪辑可以应用于该模型中的一组图形;最里面的剪辑将与外部剪辑相交，以产生最终的剪辑。默认情况下，仅显示剪辑内部的几何图形。ClipStyle 可以通过指定要应用于剪辑内部和&#x2F;或外部几何图形的颜色来覆盖此行为。下图显示了应用于房屋模型以显示内部的剪贴平面。\nSection-cut graphics默认情况下，与剪裁平面相交的几何体会在相交处被简单地截断。例如，如果你把一堵墙切成两半，墙的轮廓将显示在剪贴平面上，允许你看到墙的 “内部”，如上图所示。一个显示样式的CutStyle可以在剪辑平面的交叉点上产生分段切割的几何图形，这样，被切成两半的墙将继续显示为一个实体对象。CutStyle也可以选择性地覆盖几何体在剪贴交汇处的外观，包括可见边缘的显示。从上面看被剪切的房屋模型，在剪切平面的交叉点上产生了截面切割图形。具有可见边缘的分段切割图形，根据CutStyle进行处理。\n2d drawings and sheetsiTwin.js支持两种类型的2D模型–Drawings和Sheets，它们可以分别使用DrawingViewState或SheetViewState进行可视化。\n\nDesign model中用来存放用户的设计内容；\nDrawing model中是对Design model的某个保存视图（SavedView）的引用，然后在Drawing model中做标注；\nSheet model又是对Drawing model的引用，可将多个Drawing model组合到一个Sheet model中供最终的出图打印；\nDesign model和Sheet model都可以是3D和2D的，但Drawing model只能是2D的。\n\nDrawings图形通常用于提供空间模型子集（例如，楼层平面图、剖面图和立面图）的二维表示形式。它们通常是通过用一个或多个剪裁平面对空间视图进行切片来自动生成二维切割几何图形。切割后的几何图形通常与生成它的原始 三维几何图形保持对应关系。随后，可以使用文本、标注和度量值对绘图进行注释。在截面绘制的特殊情况下，仅针对 三维几何的一小部分（例如，舱口线、门摆动等）生成 二维几何图形，或者根本不生成任何几何图形。在这种情况下，空间视图的内容将直接渲染到应用了修剪平面的 二维工程视图中。其他类型的图形可能与空间坐标（例如，逻辑示意图或草图）没有相关性。从空间视图生成的带注释的平面图图形：\nSheets图纸代表现实世界中具有精确物理尺寸的图纸，旨在打印到实际的纸张上–尽管涉及图纸的纯数字工作流程正变得越来越普遍。大多数图纸都有一个代表其物理尺寸的边界。在这个边框内，它们可以嵌入任何数量的（按比例缩小的）图纸和&#x2F;或空间视图，以及像时间表和标题块这样的注释。\n如下为一张带有标题和两个嵌入式平面图的图纸。\n\nHyper-modeling超建模是一种将 2D 文件集成到空间视图中的方法。激活超建模后，将显示一组标记，对应于空间模型中的剖面草图定位。点击标记可在三维坐标空间中切换相应图形或图纸的显示，从而允许用户在其空间模型的背景下可视化其 2D 文档（包括注释）。\n\nEdge display在许多面向传统CAD 的工作流中，曲面边缘的可视化可能与曲面本身的可视化一样重要。iTwin.js渲染器支持以线框模式（无曲面）或与其曲面一起显示边缘。当同时显示曲面和边时，将采用特殊的渲染技术以确保边缘总是画在其对应的曲面前面，以防止发生 z 锯齿。\nRender modesiTwin.js支持四种内置渲染模式，其中包括影响边缘和表面的显示方式。\n\n线框：仅绘制边缘。\n平滑着色：使用材质和光照绘制表面。还可以选择显示边。\n实体填充：使用底层元素颜色在没有材质或光照的情况下绘制曲面。每个曲面的边缘都以所选的灰色阴影显示，以便与元素颜色和视图的背景色形成最佳对比度。\n隐藏线：使用视图的背景色绘制表面时不使用材质或照明。边缘使用基础元素颜色显示。\n\n后面两种模式有点老套；一般来说，使用平滑阴影模式并启用可见边缘，可以获得更多视觉上的效果。\nEdge appearanceDisplayStyleState可以使用HiddenLine.Settings覆盖它们的颜色、宽度和&#x2F;或样式来定制边缘显示样式。“Comic Book”, “Schematic”, “Illustration”, 和”Architectural: Monochrome” 都是边缘显示效果\nAppearance overridesiTwin.js渲染器提供了动态覆盖tiles中要素外观（与几何元素相关）的功能。渲染器使用嵌入在每个tiles中的特征表来生成查找表，顶点着色器可以从中获取覆盖。可以使用FeatureOverrides覆盖以下方面：\n\n颜色和透明度；\n线宽和样式；\n可见性 - 是否绘制了要素；\n强调性 - 应用于特征的轮廓效果，使其脱颖而出；\n定位性 - 工具与功能交互的能力；\n是否应用材质。\n\n外观覆盖可以基于模型、元素、子类别、几何类的任意组合来应用。它们从各种来源聚合，包括：\n\n由CategorySelector指定的可见类别;\n由显示样式指定的每个模型、每个子类别和每个几何类的覆盖；\n控制视图动画的 RenderTimeline 脚本;\n显示样式的PlanProjectionSettings;\n由Tile树提供的FeatureAppearanceProviders;\n在视口中注册的任意数量的 FeatureOverrideProvider。\n\n在下图中，EmphasizeElements将重点放在少数元素上，同时通过覆盖其颜色和透明度来淡出其余元素：\nParticle effectsiTwin.js支持使用粒子系统显示大量类似对象（称为”粒子”）。使用粒子收集生成器，可以定义每个粒子要使用的图像及其比例、位置、旋转、透明度和其他属性。这些属性可以根据你的模拟逻辑每隔一帧就更新一次，并使用实例化技术有效地重新渲染。除了在模拟火灾和天气等效果方面的典型用途外，粒子集合还可用于模拟和物联网可视化。例如：\n\n雨雪效果\n火灾和烟雾效果\n使用从OpenStreetMaps获得的道路信息对世界上任何地方穿越道路的数万辆汽车进行交通模拟，以进行准确的导航（示例即将推出）。\n\n在下图中，使用粒子效果模拟了降雪：\nScreen-space effects视口空间效果允许应用程序操作视口生成的图像。使用ScreenSpaceEffectBuilder，应用程序提供着色器代码片段，这些代码段将图像作为输入并输出新图像。这个简单的过程可以产生各种各样的效果，而且这些效果可以被链起来，使一个效果输出的图像成为下一个效果的输入。此示例演示了镜头失真、晕影和饱和度效果。具有广角镜头的相机，未应用视口空间效果：与上面相同的视图，应用视口空间效果来模拟镜头失真：\nClassification and masking空间分类和平面剪辑遮罩（掩膜）是使用一组模型自定义另一组模型的可视化和&#x2F;或行为的相关方法。普遍适用于实景模型。\nSpatial classification空间分类使用一个或多个设计模型，通过将实景模型的某些部分与设计模型中的元素相关联，对实景模型进行处理。支持两种类型的分类：\n\n平面分类：将设计模型投影到一个平面上，与从图元封装中拉伸的体积相交的实景模型区域将按该图元进行分类。\n体积分类：与元素的 3d 体积相交的实景模型区域按该元素进行分类。\n\n实景模型的已分类和未分类部分可以显示为法线、隐藏或灰显。还可以使用分类元素的颜色对已分类的部分进行重新着色，或进行隐藏。工具与实景模型的分类区域进行交互，就好像它们正在与分类元素交互一样。例如，将鼠标悬停在已分类区域上将显示一个工具提示，其中包含有关分类元素的信息，选择该元素可以显示该元素的属性。\nPlanar clip masks与平面分类一样，设计模型被投射到一个平面上以创建掩模。然后，该遮罩可用于剪除实景模型、地形和&#x2F;或地图图像的部分。默认情况下，与遮罩相交的部分被剪掉。用于构建遮罩的几何体可以根据模型、子类别和元素ID进行过滤。\n下图为采石场的实景模型与背景地图一起显示–观察地图如何掩盖采石场的挖掘部分:同样的采石场模型，现实模型完全掩盖了背景图，露出了挖掘的痕迹:下图为地铁隧道与城市聚合体的例子，设计模型被实景模型所掩盖，从而使地下部分显示为半透明状:\nThematic visualization主题显示将颜色渐变应用于场景中，以帮助可视化场景中几何图形的属性。支持以下属性：\n\n高程：颜色是根据世界空间中的 Z 位置分配的。\n坡度：颜色是根据表面和给定轴（通常是世界向上矢量）之间的角度分配的。\n山体阴影：颜色是根据太阳照射在表面上的方向分配的。\n传感器距离：给定放置在场景中任意数量的传感器并提供传感器读数值，根据传感器提供的值分配颜色，并按与每个传感器的距离加权。\n\n渐变可以平滑地应用，也可以使用离散的步骤。阶梯渐变可以选择显示每个离散颜色之间的分隔符;或者分隔符可以自行显示，从而生成等值线可视化。它可以应用于设计模型、实景模型和 三维地形网格。\nExample images主题高度 - 阶梯式：主题高度 - 带分隔符的阶梯：主题高度 - 等值线：主题山体阴影：主题坡度：\nTimeline animation时间轴动画允许在一段时间内可视化 iModel 内的变化。例如，施工项目通常希望在施工计划期间可视化模型在给定点的状态。为此，可以将 RenderSchedule.Script 与描述此可视化效果的显示样式相关联。计划脚本将场景中的元素集划分为动画节点。每个节点都有一个相应的时间轴，该时间轴描述了如何通过以下方式对元素进行动画处理：\n\n更改其颜色、透明度或可见性;\n更改不同的剪切平面、角度；\n更改对应时间变化的差异。\n\n随着脚本播放过程中时间的推进，将查阅时间线在当前时间点的值。这些值可以在时间点之间线性插值，也可以量化为离散时间点，根据脚本调整颜色和透明度。下面的GIF说明了根据其渲染时间轴构建模型的动画：\nElement graphicsiTwin.js渲染器旨在渲染Tiles，而不是渲染元素。但在某些情况下，显示单个元素的图形很有用。例如，修改元素几何图形的工具可能希望在用户与元素交互时显示其效果的预览。或者，模拟可能希望临时为少数元素添加动画效果。TileAdmin.requestElementGraphics 接受元素 Id 或任意 GeometryStream（从中生成图形）以及其他选项（如指定所需细节级别的LOD）。它以 iModel Tiles的格式返回图形，然后可以将其提供给读取ElementGraphics以生成用于在视口中显示和渲染。爆炸功能即可清晰说明此节内容。\nMulti-sample anti-aliasingiTwin.js渲染器支持多样本抗锯齿（”MSAA”），以显示渲染平滑锯齿线和多边形边缘。所生成图像的质量，以及帧速率的潜在降低会随着请求的样本数量而增加。样本数为 2 的幂，最高可达图形硬件支持的最大值。大多数支持 MSAA 的硬件最多支持 8 个或 16 个样本 。因此， 2、4、8 和 16 表示离散的抗锯齿程度。中间值向下舍入到最接近的 2 的幂。值为 1 或更小表示不应应用消除锯齿。可以通过以下两种方式之一启用此功能：\nControlling anti-aliasing for a specific viewport通过Viewport.antialiasSamples 获取或设置视口的MSAA样本数。\nviewport.antialiasSamples = 8; // Enable 8x MSAAviewport.antialiasSamples = 1; // Disable MSAA\n\nControlling anti-aliasing for all viewports通过ViewManager.setAntialiasingAllViews为所有当前和后续打开的视口设置MSAA样本数。\nIModelApp.viewManager.setAntialiasingAllViews(8); // Enable 8x MSAAIModelApp.viewManager.setAntialiasingAllViews(1); // Disable MSAA\n\nComparison images左侧无抗锯齿，右侧为 8 个 MSAA。窗户和楼梯周围的效果特别明显：左侧无抗锯齿，右侧为 8 个 MSAA。这种效果在远处的树叶周围尤其明显：\nWiremesh displayiTwin.js渲染器支持显示表面的边缘，但实景模型通常不提供边缘信息，有时可视化网格的基础三角测量会更有用。ViewFlags.wiremesh 为设计模型和实景模型启用线网显示。应用于实景模型的可视化网格：应用于工厂模型的可视化网格：\n","categories":["computer graphics"],"tags":["iTwin Platform"]},{"title":"iTwin.js 理论基础 - 基础工具","url":"/2021/06/25/iTwin.js%20%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%20-%20%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/","content":"Tools是指用户执行操作的JavaScript类。有两个主要工具类别，即时工具和交互式工具。\n即时工具（Immediate Tools）即时工具无需进一步输入即可立即执行其分配的任务。它们不会成为活动工具，而是作为工具的直接子类实现。即时工具最大的特点是用户通过工具的调用直接导致应用程序状态发生改变。\n交互式工具（Interactive Tools）有三种交互式工具分类，每一种都是通过对InteractiveTool进行子类化来实现的，来最好地满足特定的目标。\n\nViewTool操纵视图的交互式工具。例如执行平移、缩放和旋转等查看操作。\n在执行过程中暂停活动工具，完成后恢复活动工具。\n前端软件包提供了一套全面的视图查看工具；大多数iTwin.js应用程序不需要实现自己的工具。\n\n\nInputCollector用于通过捕捉或定位iModel中的元素来收集当前基本工具的输入。\nInputCollector将挂起活动的PrimitiveTool，并且可以由ViewTool挂起。\n当工具冲突时不修改 iModel 内容。\n前端包括几个AccuDrawShortcuts实现。\n\n\nPrimitiveTool用于与iModel的图形交互，可用于实现创建或修改几何图元的工具。\n调用时，变成为活动工具，对用户输入（如数据点、鼠标移动、触摸、按键和重置）作出反应。\nPrimitiveTool是iTwin实现的最常见的工具类型。\n\n\n\n工具调用通常通过点击相关图标或使用命令解析器调用工具。可以使用ToolRegistry.run方法以编程方式调用工具，该方法将toolId作为第一个参数，然后允许将可选参数传递给工具的构造函数及其run方法。\n工具管理ToolAdmin类监视来自视图窗口的低级输入的集合（点击事件、移动事件、触摸事件、计时器事件等）;将这些输入解释为工具可以轻松处理的高级事件（iTwin.js坐标中的数据点，运动事件等，并应用了适当的锁定和精确捕捉校正）;并将这些输入路由到相应的工具。解释的高级事件的路由如下：\n\n如果存在激活的工具，则事件将定向到该工具。激活的工具可以处理特定事件，也可以忽略它。\n如果激活的工具不处理特定事件，则可能会将其定向到Idle Tool\n\n如上所述，ViewTool或Input Collector可以暂时中断Primitive tool。ToolAdmin 则以一种灵活的方式处理该序列。\n默认工具（Idle Tool）在iTwin.js中   `Idle Tool`是 `Interactive Tool`的一个子类，用于查找启动View工具的输入。\n\n对于iTwin应用来说，有一些默认的工具事件。如果没有激活的工具或者激活的工具没有指定事件，输入事件将转发到默认工具。鼠标事件和触摸手势转换都是默认的工具，如：旋转、平移、缩放、拟合等。如下为默认工具:\n\n鼠标&#x2F;键盘: LMB鼠标左键、MMB鼠标中键、RMB鼠标右键\nmmb: 平移\nshift-mmb: 旋转\nwheel: 缩放\ndouble-mmb: 调整视图\n\n\n触摸屏:\nsingle-finger drag: 旋转\ntwo-finger drag: 平移\npinch: 缩放\ndouble-tap: 调整视图\n\n\n\n","categories":["computer graphics"],"tags":["iTwin Platform"]},{"title":"iTwin.js 理论基础 - 存储结构","url":"/2021/06/10/iTwin.js%20%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%20-%20iModel/","content":"iModel OverviewiModel是一个基于SQLite的分布式关系数据库，其模式由BIS定义。iModel包含了有关单个基础架构资产的全部信息，例如物理和功能模型，图纸，规格，分析模型等。一个iModel可能拥有多个副本，每个副本都保存在briefcaseDb 中，并通过iModelHub的ChangeSet同步，就像Git和GitHub的关系一样。使用iModels，每个用户都有数据库的完整副本。\nEvery iModel has a GUIDiModel 保存单个基础架构资产的相关信息。它们都用一个唯一标识符进行唯一标识，因此iModelHub可以跟踪和保护它们。每个Briefcase 都维护其 iModel 的 GUID，因此其所有者可以控制对它的访问。\nAn iModel occupies physical space on the earth每个 iModel 都有一个空间坐标系，可以定位到地球上的任何地方。通过这种方式，多个iModel可以相对于彼此以及相对于外部实景模型，地图和地理信息系统等进行定位。iModels 有一个名为”项目范围”（Project Extents）的属性，用于描述它们的作用域，iModel 的空间坐标系中的所有几何图形都必须包含在内。\nThe format of information in an iModel is defined by BISiModel中的信息格式是由BIS定义的。基础架构模式是一系列特定领域的类定义，定义了iModel中实体的属性和关系。\nAn iModel is comprised of many Models在一个iModel 中，信息的逻辑分区是由模型定义的。有许多类型的模型，与它们所持有的信息类型是相对应的（例如空间，功能，绘图等）。在同一 iModel 中，每种类型的模型可以有多个实例，即一个iModel是由许多模型组成。\nA Model is comprised of many Elements元素是 BIS 中最小的可独立寻址构建块。每个元素都由一个且仅一个模型拥有。一个模型是由许多元素组成的元素的类型很多，与它们所包含的信息类型相对应。只有几何模型中保存的几何元素在视图中可见。\niTwin.js makes iModels accessible anywhereiTwin.js库的目的是使iModels可供所有人随时随地访问，用于iModel拥有者的任何操作。它提供了创建、修改、查询、显示和分析 iModel 的方法。\nECSQL is the query language of iModelsiModel是一个SQLite数据库。SQLite对SQL有广泛的支持，包括索引和全面的查询规划。但是，由于BIS类到数据库表的映射，直接将SQL与iModels一起使用并不简单。因此，iTwin.js包含 ECSQL，以在类和属性名称（而不是表和列名称）方面形成 iModel 的查询。在内部，ECSQL被转换为SQL并传递给SQLite以实现出色的性能。\n","categories":["computer graphics"],"tags":["iTwin Platform"]},{"title":"iTwin.js 理论基础 - 平台架构","url":"/2021/06/03/iTwin.js%20%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%20-%20%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84/","content":"Software Architecture for iTwin.js platform\n支持在任何云或本地运行的基于 iModel 的服务\n支持基于 iModel 的 网页&#x2F;桌面&#x2F;移动应用\n跨平台应用的业务逻辑\n跨平台应用的UI界面\n\n后端架构:\n\nApplication Backend (TypeScript)\niTwin.js Backend Framework (TypeScript)\nJavaScript Runtime with C++ Interoperability\niTwin.js Native Libraries (C++)\n\n前端架构:\n\nApplication Frontend (TypeScript&#x2F;JavaScript)\niTwin.js Frontend Framework (TypeScript)\nHTML GUI\nWeb Browser\n\n\nWebiTwin.js Web App 后端是 Node.js 应用程序。Node.js提供了V8 JavaScript引擎和N-API，用于在C++中编写Node Addons。这就是iTwin.js原生库暴露给iTwin.js后端框架的方式。应用程序逻辑是用 TypeScript 编写的，并调用从包中公开的 TypeScript API。@itwin/core-backend交互式 Web 应用程序的代理和后端之间的后端体系结构是相同的。Web 应用前端在 Web 浏览器中运行，并使用 HTML GUI 进行演示，以及从包中暴露的远程过程调用（RPC）的API来请求后端服务前端 –&gt; 后端通信是通过 HTTPS 进行的，用于交互式 Web 应用程序。\nDesktopiTwin.js桌面应用程序使用Electron框架。后台架构与iTwin.js Web应用程序相同，因为Electron也使用Node.js。前端架构的主要区别是，一个嵌入式Chromium浏览器取代了独立的Web浏览器。\n前端 –&gt; 后端的通信是通过Electron提供的进程间通信（IPC）。请注意，iTwin.js桌面应用程序总是有至少两个（一个前端和至少一个后端）进程同时活动。\nMobileiTwin.js移动应用程序使用内置于 Android SDK 和 iOS SDK 中的 JavaScript 引擎和 Web 浏览器 GUI 控件。前端 –&gt; 后端通信是通过函数调用和两个单独的 JavaScript 进程之间的消息进行的。\nComparison下图比较了 Web、桌面和移动应用程序的体系结构，并显示了如何实现可移植性和重用的目标。\n","categories":["computer graphics"],"tags":["iTwin Platform"]},{"title":"iTwin.js 理论基础 - 基础环境","url":"/2021/05/22/iTwin.js%20%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%20-%20%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/","content":"1.系统版本\nDebian 9 “Stretch” 和Debian 10 “Buster”\nWindows 10 version 1803及以上版本\nMacOS 10.15 及以上版本\n\n2.Node.js 版本\n\n\nNode Version\nSupported\n\n\n\nNode 14.x\n✔️\n\n\nNode 12.x\n✔️\n\n\nNode 10.x*\n✔️\n\n\nNode &lt;10.17\n❌\n\n\n3.系统环境\nLinux\nGLIBC 2.24 (or greater)\nGLIBCXX 3.4.22 (or greater)\n\n\nWindows\nVisual Studio 2017 C Runtime\n\n\n\n4.浏览器iTwin.js需要运行在支持JavaScript ES6的浏览器上，web浏览器的WebGL实现的质量对显示性能有重要影响。\n\nChrome \nFirefox\nSafari\nOpera\nMicrosoft Edge\n\nPS：不支持Internet Explorer 和 “Old” Edge，其他浏览器未经测试，不推荐使用\n5.Electron\nWindows\n\n","categories":["computer graphics"],"tags":["iTwin Platform"]},{"title":"iTwin.js 理论基础 - 编码规范","url":"/2021/05/20/iTwin.js%20%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%20-%20%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/","content":"下文是我们希望所有iTwin.js开发者遵循的TypeScript编码准则。在默认情况下，这些准则是通过我们的TSLint配置文件（tslint.json）执行\n&quot;extends&quot;: &quot;./node_modules/@bentley/build-tools/tsconfig-base.json&quot;\n\n\nName\n\n对类、枚举值使用PascalCase（帕斯卡）命名。（eg:&quot;IModelApp&quot;）\n对函数、属性和局部变量使用camelCase（驼峰）命名。(eg:&quot;getFirstViewDefinitionId&quot;)\n不要使用前缀来作为接口名称。（eg:&quot;imjs&quot;）\n对私有属性使用前缀。（eg:&quot;_onIModelSelect&quot;）\n在命名过程中使用全部单词，尽量少用缩略语。\n\nFile\n\nTypeScript文件使用.ts作为文件扩展名。\nTypeScript的文件名应该是PascalCase命名。\n\nType\n\n在不需要多个组件共享使用类&#x2F;函数时，不要导出。\n不要在全局命名空间中引入新的类型。\n在一个ts文件中，首先要进行类的定义。\n\nDo not use null\n\n尽可能不要使用null或者undefined。\n\nOperators\n\n尽可能使用===/!==运算符而不是==/!=。\n\nStrings\n\n对字符串使用双引号。\n\nGeneral Constructs\n\n始终使用分号;我们的TSLint规则强制执行这一点，在VSCode中会提示出错，单不影响使用。\n使用 {} 替代 new Object()。\n使用 [] 替代 new Array()。\n\nMake judicious use of vertical screen space\n\n尽量不要使用多余空行。例如，一个函数的第一行不应该是一个空行。\n\n尽量不要把导入语句中的每个导入放在单独的一行。如果你使用Visual Studio Code作为你的编辑器，使用TypeScript Import Sorter扩展的默认设置来自动格式化导入语句。\n\n尽量不要使用巧妙的&#x2F;漂亮的多行注释块来分隔代码部分。\n\n尽量不要让只有一条函数语句的函数放在同一行。\n//Nopublic middle(): number &#123; return this.minimum + ((this.maximum - this.minimum) / 2.0); &#125;//Yespublic middle(): number &#123;   return this.minimum + ((this.maximum - this.minimum) / 2.0);&#125;\n\nif语句或循环的主体应该在一个单独的行上，即使主体只包含一行代码。\n// Noif (meow) return &quot;cat&quot;;// Yesif (meow) return &quot;cat&quot;;\n\n结尾的大括号应该是一个空行\n// No if (minimum &gt; maximum) &#123;  const temp = minimum;  minimum = maximum;  maximum = temp;&#125;return maximum - minimum;\n// Yesif (minimum &gt; maximum) &#123;  const temp = minimum;  minimum = maximum;  maximum = temp;&#125;return maximum - minimum;\n\n尽量不要省略单行代码的大括号&#123;&#125;\n// No (closing brace wastes a line) !!!if (meow) &#123;  return &quot;cat&quot;;&#125;\n// Correct (no braces) !!!if (meow)  return &quot;cat&quot;;\n\nStyle\n\n在匿名函数表达式上使用箭头函数。\n\n不要使用var，而是尽可能使用const或let。\n\n每个变量语句使用一个声明（eg:let x = 1; let y = 2）。\n\n&#123;&#125;结构的周围不应有任何空白。,``:``;这些结构体中的运算符后面都有一个空格。\nfor (let i = 0, n = str.length; i &lt; 10; ++i) &#123; &#125;if (x &lt; 10) &#123; &#125;public calculate(x: number, y: string): void &#123; . . . &#125;\n\n每次缩进使用两个空格，不要使用制表符。\n\n建议在编辑其中打开tslint。\n\n\nreturn\n\n当返回语句有返回值时，不要使用()。\nreturn (&quot;Hello World!&quot;); // badreturn &quot;Hello World!&quot;; // good\n\n某些编程流派认为，每个方法都应该只有一个返回语句，iTwin.js建议当你认为没有理由继续执行下去就应该立刻返回。\n// bad!!public getFirstUser(): Person | undefined &#123;  let firstUser?: Person;  if (this.hasUsers()) &#123;    if (!this.usersValidated()) &#123;      if (this.validateUsers())        firstUser = this.getUser(0);    &#125; else &#123;        firstUser = this.getUser(0);    &#125;  &#125;  return firstUser;&#125;// ok!!public getFirstUser(): Person | undefined &#123;  if (!this.hasUsers())    return undefined;  if (!this.usersValidated() &amp;&amp; !this.validateUsers())      return undefined;  return return this.getUser(0);&#125;// best!!! For a simple case like this that is deciding between 2 return valuespublic getFirstUser(): Person | undefined &#123;  const userInvalid = !this.hasUsers() || (!this.usersValidated() &amp;&amp; !this.validateUsers());  return userInvalid ? undefined : this.getUser(0);&#125;\n\n尽可能明确定义一个返回类型，这也是TypeScript的编程理念。\n// bad!! No return type specifiedpublic getOwner(name: string) &#123;  if (this.isReady)    return this.widget.getOwner(); // is this a Person???  ...  return new Person(name);&#125;// good!!public getOwner(name: string): Person &#123;  if (this.isReady)    return this.widget.getOwner(); // if this is not a Person, compile error  ...  return new Person(name);&#125;\n\n当调用方法时，明确指定返回类型。在异步方法调用的情况下，这种做法可以防止省略await关键字。\n// bad!! no return type specified for async call, and missing await is not caught by the compilerconst iModels = iModelHub.getIModels(projectId);// good!! omitting the await would be caught by the compiler as a type mismatchconst iModel: IModel[] = await iModelHub.getIModels(projectId);\n\nGetters and Setters\n\ngetter的常见用法是有一个私有成员，该成员在类中是私有读&#x2F;写的，但对公共API是只读的。\nclass Person &#123;  private _name: string;  public get name(): string &#123; return _name; &#125; // read-only to public API, so no setter provided&#125;\n\n如果getter提供的值是在构造函数中建立的，并且永远不会被改变，可以参照下文。\nclass Person &#123;   constructor(public readonly name: string) &#123; &#125;&#125;\n\ngetters和setters的另一个常见用法是，当你想给一个公共成员，但你实际上并不以这种方式存储数据。\nclass PersonName &#123;  constructor (public firstName: string, public lastName: string) &#123; &#125;  public get fullName(): string &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;  public set fullName(name: string): void &#123;    const names: string[] = name.split(&quot; &quot;);    this.firstName = names[0] || &quot;&quot;;    this.lastName = names[1] || &quot;&quot;;  &#125;&#125;\n\nuse “?:” syntax vs. “ | undefined”\n\n当声明成员变量或函数参数时，使用TypeScript的&quot;?: &quot;语法，而不是为可以未定义的变量添加&quot;| undefined&quot;。class Role &#123;  public name: string;  public description: string | undefined; // Wrong !!&#125;class Role &#123;  public name: string;  public description?: string; // Correct !!&#125;\n\nDon’t repeat type names unnecessarily\n\nTypeScript是向JavaScript增强类型的，编译器会自动推断类型，因此没有必要在每个成员或变量的声明中装饰其类型，适当的添加类型。\n如果一个函数超过一行，最好总是包括它的返回类型，以确保没有返回路径有一个意外的类型。let width: number = 7.3; // useless type declarationpublic isReady: boolean = false; // useless type declarationpublic readonly origin: Point3d = new Point3d(); // useless type declarationlet width = 7.3; // correctpublic isReady = false; // correctpublic readonly origin = new Point3d(); // correctconst upVector: Vector3d = rMatrix.getRow(1); // good, helps readability. Not strictly necessary.\n\nAsynchronous Programming\n\n使用Promise\n使用return Promise.reject(new MyError())而不是解析为错误状态 。传入 Promise.reject 的对象应该是 Error 的子类。\n使用async/await比.then()更好\n\nCopyright notice\n\n每个.ts文件的第一行/*---------------------------------------------------------------------------------------------* Copyright (c) Bentley Systems, Incorporated. All rights reserved.* See LICENSE.md in the project root for license terms and full copyright notice.*--------------------------------------------------------------------------------------------*/\n\nSource Code Editor\n\n推荐使用Visual Studio Code\n建议为Visual Studio Code配置ESLint扩展，并使用我们的 @bentley&#x2F;eslint-plugin\n\nReact Function Components\n有多种方式定义React函数组件：\n\nconst Xyz: React.FunctionComponent&lt;XyzProps&gt; = (props) =&gt; &#123;...&#125;\nconst Xyz: React.FC&lt;XyzProps&gt; = (props) =&gt; &#123;...&#125;\nfunction Xyz(props: XyzProps) &#123;...&#125;//goodexport function Xyz(props: XyzProps) &#123;  return &lt;div&gt;Hello World!&lt;/div&gt;;&#125;\n\n","categories":["computer graphics"],"tags":["iTwin Platform"]},{"title":"iTwin.js Roadmap","url":"/2021/05/14/iTwin.js%20Roadmap/","content":"本文概述了iTwin.js平台的开发路径，对功能开发的优先级进行简单说明，它会随着iTwin.js每个版本的更新而更新。\n主题我们将使用以下主题（更具实际的需求不断改变）来推动iTwin.js的发展：\n\n作为基础设施数字孪生的开放平台，将 BIM 模型、GIS 数据、实景数据、IT 和 OT 联合在一起，实现无缝的用户体验。\n分离对云供应商、操作系统和浏览器之间的依赖。\n高性能、易扩展性、安全性和稳定性是iTwin.js的核心。\n让使用 iTwin.js 进行开发尽可能简单、高效。\n尽可能遵守开源标准和规范。\n构建一个创新和企业的生态系统。\n\n路线图选中的框表示在最新版本中完成的功能。如果未选中的框，则表示该功能的工作正在进行中或暂定于将来发布。本文档的各个部分功能的会随时间的推移而变化，项目通常按优先级排序（注意：优先级顺序并不一定代表完成顺序，因为优先级较低但简单的功能可能会很快完成）。如果某个项目的优先级低于您的预期，则可以通过提交 PR 来提出自己的意见和建议。点击此连接提交PR。\n可视化\n√支持硬件抗锯齿\n√点云和地形的主题显示\n×支持压缩的纹理格式\n√粒子效果\n√屏幕空间效果\n×大型场景动画（例如，行人模拟、天气动画、灾难模拟）\n×支持大气层渲染效果\n\n \n\n### 拓展\n\n\n\n×支持与UI技术无关的”内置”和运行时扩展（即不依赖于React，Angular，Vue.js等）\n×支持添加工具和最小的 UI 功能\n×创建用于构建扩展的示例和模板\n×创建快速简便的支持，以便在扩展的托管应用程序中进行创建 - 例如，iTwin Viewer\n\n地理信息系统显示\n√扩展基础地图的支持（AzureMaps、MapBox等），基础地图的透明度可以独立于图层来控制。\n√添加对显示连接到实时 WMS、WMTS、AzureMaps、MapBox 或 ArcGIS REST API 服务器的栅格地图图层的支持。可以独立控制地图图层的可见性和透明度。图层可以作为背景附加到 BIM 几何图形下方，也可以作为叠加层附加到 BIM 几何图形上方。\n\n微软集成\n×提供用于直接在 Microsoft Teams 中托管 iTwin.js 应用程序的 API。\n\nET&#x2F;IT&#x2F;OT 集成\n×为iModels中的工程项目、企业系统和实时物联网传感器、相机、控制器、设备和处理器之间的接口提供工作实例和模板。\n×创建用于增强与具有 IOT 链接元素的工程设计工具的连接器同步的数据的工具。\n×增强常见物联网模式和查询引擎的BIS模式。\n\n代理部署\n×提供通过 Kubernetes 部署的代理的工作示例和模板。\n×对 iModel 执行由 iModelHub 中的相关事件触发的 iModel 操作。\n\niTwin Viewer\n√创建功能齐全的 iTwin Web 查看应用程序平台，可部署在任何云基础架构上。\n×提供必要的基础结构，以便在任何基于 iTwin Viewer的解决方案中托管扩展。\n\n点云数据\n×支持大规模点云基于时间的差异可视化。\n\n实景数据\n√支持为大型实景数据实施网格化提供线性转换。\n\n地理照片和全景图\n×改进服务器端对照片和全景图标签的提取。\n×将地质照片包纳入可从任何iTwin浏览器应用程序加载的扩展程序。\n\n地理定位（普通）\n√提供一种方法来访问 iModel 和垂直的地理位置 gcs 定义。\n×根据 orbit gt 实现实现前端重新投影。\n×实现新的地理坐标服务的客户端。\n×从新的地理坐标服务客户端获取大地水准面分离。\n×在 iTwin 工作区支持中完成系统网格文件。\n\niModel Transformations\n√创建示例和模板，说明 iModel 到 iModel 转换和同步的用法。\n\niTwin.js 连接器框架\n√支持使用 iTwin.js 后端创建多进程连接器。一个进程与源应用程序 API 链接以读取源应用程序文件。然后，它通过IPC与另一个iTwin.js进程进行通信，以更新iModel。\n\niModel 编辑应用程序\n√支持通过 Electron 在桌面上进行交互式 iModel 创建、编辑和扩充。\n\n移动设备支持\n×最大限度地降低移动浏览器的内存、功耗和带宽要求。\n√提高触摸和小屏幕外形的可用性。\n×支持完全离线和偶尔连接的平板电脑和手机（iOS和Android）。\n\n非图形数据显示\n√通过支持的ECSchema版本过滤演示规则和规则集。\n√在以下情况下，自动更新所有规则驱动的组件中的数据：\n√源iModel数据的更改\n√演示文稿规则更改\n√表示规则集变量更改\n\n\n\n属性相关显示\n√嵌套属性分组。\n√选择目标元素的可单击导航属性。\n×更好地支持复合属性（数组、结构、点）。\n×支持关系属性。\n×支持临时属性。\n\n用户界面\n√扩展基于面板的 AppUi 的功能。\n×改善移动设备上的触摸支持和用户体验。\n√桌面 Electron 应用程序的多窗口支持。\n×增强辅助功能和键盘导航。\n×增强 UiItemProvider 以支持：\n×更多文字编辑器，尤其是读&#x2F;写工作流所需的文字编辑器\n×异步列表填充\n\n\n√提供 API 以允许应用、扩展和程序包向”设置”阶段提供设置。\n\n与外部系统的接口\n√为建立其他文件格式（如glTF、OBJ、USD）的导出器提供基础功能。\n√展开图形提取的筛选和质量控制选项。\n\n开发人员体验\n√将 iTwin.js和相关存储库迁移到 GitHub。\n\n","categories":["computer graphics"],"tags":["iTwin Platform"]}]